<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"github.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.24.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="blog of dz">
<meta property="og:url" content="http://github.com/index.html">
<meta property="og:site_name" content="blog of dz">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="dz">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://github.com/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>blog of dz</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">blog of dz</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">dz</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://github.com/2025/09/08/W&L%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%85%BC%E5%AE%B9%E4%B8%AD%E6%96%87%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dz">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog of dz">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | blog of dz">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/08/W&L%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%85%BC%E5%AE%B9%E4%B8%AD%E6%96%87%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">W&L跨平台兼容中文技巧</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-09-08 19:44:35 / 修改时间：20:14:41" itemprop="dateCreated datePublished" datetime="2025-09-08T19:44:35+08:00">2025-09-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Windows-Linux-跨平台兼容中文技巧"><a href="#Windows-Linux-跨平台兼容中文技巧" class="headerlink" title="Windows &amp; Linux 跨平台兼容中文技巧"></a>Windows &amp; Linux 跨平台兼容中文技巧</h1><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h2><p>最近项目需要同时支持Linux和Windows平台，而在Windows下使用GBK编码，而Linux默认使用UTF-8。<br>项目背景为QT项目。在输入如QString类型的路径时，查找文件路径因平台不同而出错。</p>
<h2 id="2-解决方法"><a href="#2-解决方法" class="headerlink" title="2.解决方法"></a>2.解决方法</h2><p>先应用方法参数分析，使用场景涉及cv::imread&#x2F;write，cv构造函数接受const string类型的参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mat cv::imread ( const String &amp;  filename,int  flags = IMREAD_COLOR )</span><br></pre></td></tr></table></figure>
<p>而另一个场景涉及文件系统的创建fstream，构造函数同时接受const string 和const char *类型的参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fstream （const string&amp; filename，ios_base::openmode mode = ios_base::in | ios_base::out）</span><br><span class="line">fstream （const char* filename，ios_base::openmode mode = ios_base::in | ios_base::out）</span><br></pre></td></tr></table></figure>
<p> 两处场景都需要const string类型的参数。这里设计一个宏</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifdef _WIN32</span><br><span class="line">    #define apply(str) str.toLocal8Bit().constData()</span><br><span class="line">#else</span><br><span class="line">    #define apply(str) str.tostdstring().c_str()</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>toLocal8Bit是将Qstring转换为本地8位编码，返回QByteArray，QByteArray与const char *类似,可以使用constData转换。<br>而linux平台可以使用tostdstring方法将QString转换为标准C++字符串，然后调用c_str获取const char *。<br>const char *都可以作为上述两个场景的参数。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://github.com/2025/08/21/%E9%BE%99%E8%8A%AFopenstack%E5%8D%95%E8%8A%82%E7%82%B9%E9%83%A8%E7%BD%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dz">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog of dz">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | blog of dz">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/21/%E9%BE%99%E8%8A%AFopenstack%E5%8D%95%E8%8A%82%E7%82%B9%E9%83%A8%E7%BD%B2/" class="post-title-link" itemprop="url">龙芯openstack单节点部署</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-21 19:04:06" itemprop="dateCreated datePublished" datetime="2025-08-21T19:04:06+08:00">2025-08-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="openstack单节点部署"><a href="#openstack单节点部署" class="headerlink" title="openstack单节点部署"></a>openstack单节点部署</h1><h2 id="1-所有服务器部署系统8-4"><a href="#1-所有服务器部署系统8-4" class="headerlink" title="1.所有服务器部署系统8.4"></a>1.所有服务器部署系统8.4</h2><p>docker创建镜像<br><code>docker run -d -it -v /host_dic:/guest_dic -v /sys/fs/cgroup:/sys/fs/cgroup:ro --cap-add SYS_ADMIN --net host --name docker_name docker_id /sbin/init</code><br>根据实际修改为<br><code>sudo docker run -d -it -v /host_dic:/guest_dic -v /sys/fs/cgroup:/sys/fs/cgroup:ro -v /lib/modules:/lib/modules --cap-add SYS_ADMIN --net host --hostname controller --name dz-openstack-controller cr.loongnix.cn/loongson/loongnix-server:8.4.0 /sbin/init</code><br>-v &#x2F;lib&#x2F;modules:&#x2F;lib&#x2F;modules挂载宿主机模块（一些服务需要用到bridge,br_netfilter），–privileged 添加特权不然一些只读文件无法读写（比如neutron-linux-agent服务需要对net.bridge.bridge-nf-call-iptables文件进行读写，该文件是宿主机的只读文件权限不够），–hostname controller提前设置好主机名，更改主机名需要重启容器<br><code>sudo docker run -d -it -v /host_dic:/guest_dic -v /sys/fs/cgroup:/sys/fs/cgroup:ro -v /lib/modules:/lib/modules --privileged --cap-add ALL --net host --hostname controller --name dz-openstack-controller2 cr.loongnix.cn/loongson/loongnix-server:8.4.0 /sbin/init</code><br>用的服务器镜像为<br>cr.loongnix.cn&#x2F;loongson&#x2F;loongnix-server:8.4.0<br>openstack loongarch版源<br>[<a target="_blank" rel="noopener" href="https://pkg.loongnix.cn/loongnix-server/8.4/cloud/loongarch64/release/openstack-ussuri/]">https://pkg.loongnix.cn/loongnix-server/8.4/cloud/loongarch64/release/openstack-ussuri/]</a><br>由于自带yum镜像路径有问题,前往&#x2F;etc&#x2F;yum.repos.d&#x2F;路径下修改<br>（8.3用的路径是<a target="_blank" rel="noopener" href="http://pkg.loongnix.cn/loongnix-server/$releasever/loongnixplus/$basearch/release/">http://pkg.loongnix.cn/loongnix-server/$releasever/loongnixplus/$basearch/release/</a><br>8.4用的路径是<a target="_blank" rel="noopener" href="http://pkg.loongnix.cn/loongnix-server/$releasever/Loongnixplus/$basearch/release/%EF%BC%89">http://pkg.loongnix.cn/loongnix-server/$releasever/Loongnixplus/$basearch/release/）</a><br>[plus]<br>name&#x3D;Loongnix server $releasever - Plus<br>baseurl&#x3D;<a target="_blank" rel="noopener" href="http://pkg.loongnix.cn/loongnix-server/$releasever/Loongnixplus/$basearch/release/">http://pkg.loongnix.cn/loongnix-server/$releasever/Loongnixplus/$basearch/release/</a><br>gpgcheck&#x3D;0<br>enabled&#x3D;1<br>gpgkey&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;pki&#x2F;rpm-gpg&#x2F;RPM-GPG-KEY-LOONGNIX</p>
<p>创建好docker容器后，首先保证ssh通畅，docker容器内需要修改&#x2F;etc&#x2F;ssh&#x2F;sshd_config文件，做端口穿透（防止与宿主机ssh端口冲突），增加port 222<br>新安装的系统需要做如下设置<br><code>yum install -y vim openssh-server git rsync net-tools passwd &amp; systemctl start sshd </code><br>passwd设置root密码，以实现ssh远程认证（自己设置的是123！）</p>
<h2 id="2-配置网卡"><a href="#2-配置网卡" class="headerlink" title="2.配置网卡"></a>2.配置网卡</h2><p>所有服务器2块网卡, 配置第二块网卡 enp0s3f1作为provider 接口, 不配置ip, 同时需要修改&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;enp0s3f1 下列选项</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BOOTPROTO=none</span><br><span class="line">ONBOOT=yes</span><br></pre></td></tr></table></figure>
<p>然后重启系统</p>
<h2 id="3-下载部署脚本"><a href="#3-下载部署脚本" class="headerlink" title="3.下载部署脚本"></a>3.下载部署脚本</h2><p>选择一个节点作为控制节点controller, 在controller节点执行<br><code>yum install -y git</code><br><code>git clone https://gitee.com/leowuqiong/openstack-install.git</code><br>或者<br><code>git clone git@github.com:myLFD/openstack-install.git</code><br>(脚本后续尚待完善)</p>
<h2 id="4-配置服务器信息"><a href="#4-配置服务器信息" class="headerlink" title="4.配置服务器信息"></a>4.配置服务器信息</h2><p>进入&#x2F;root&#x2F;openstack-install目录,按照实际情况编辑config-host脚本相关信息<br>#要设置的hostname, ip, root用户密码, provider网卡接口名称(不配ip那块网卡)<br>node&#x3D;(<br>“controller,192.168.200.118,loongson123!@#,enp0s3f1”<br>“compute1,192.168.200.19,loongson123!@#,enp0s3f1”<br>“compute2,192.168.200.50,loongson123!@#,enp0s3f1”<br>……<br>)</p>
<p>执行config-host脚本, 会自动将所有服务器的hostname, 免密, &#x2F;etc&#x2F;hosts配置完成.<br>.&#x2F;config-host.sh</p>
<h2 id="5-安装控制节点"><a href="#5-安装控制节点" class="headerlink" title="5.安装控制节点"></a>5.安装控制节点</h2><p>进入&#x2F;root&#x2F;openstack-install&#x2F;openstack目录, 按照实际情况修改variable.sh,然后执行安装脚本.&#x2F;controller-install.sh</p>
<p>httpd服务启动failed：<br>&#x2F;usr&#x2F;share&#x2F;openstack-dashboard&#x2F;openstack-dashboard&#x2F;settings.py里面更改LANGUAGE_CODE&#x3D;’zh-cn’即可重新启动，原因不明</p>
<h2 id="6-安装计算节点"><a href="#6-安装计算节点" class="headerlink" title="6.安装计算节点"></a>6.安装计算节点</h2><p>登录计算节点, 进入&#x2F;root&#x2F;openstack-instal&#x2F;openstack目录, 按照实际情况修改variable.sh,然后执行安装脚本.&#x2F;compute-install.sh</p>
<p>计算节点注意在&#x2F;etc&#x2F;hosts中添加一行，以添加控制节点映射[10.40.65.186 controller]</p>
<p>如果要启动动态迁移，运行&#x2F;tools&#x2F;live-migration.sh，配置versh免密码连接<br>可以使用<code>netstat -lnpt | grep libvirtd</code>检查libvirt是否监听16509端口，显示如下则正确<br>tcp        0      0 172.16.206.6:16509      0.0.0.0:*               LISTEN      9852&#x2F;libvirtd</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在compute1节点上：</span><br><span class="line"></span><br><span class="line">virsh -c qemu+tcp://compute2/system</span><br><span class="line"></span><br><span class="line">在compute2节点上</span><br><span class="line"></span><br><span class="line">virsh -c qemu+tcp://compute1/system</span><br><span class="line"></span><br><span class="line">如果能无密码连接上去，表示配置没问题</span><br></pre></td></tr></table></figure>

<h2 id="7-计算节点发现"><a href="#7-计算节点发现" class="headerlink" title="7.计算节点发现"></a>7.计算节点发现</h2><p>所有计算节点部署完成后,登陆controller<br><code> nova-manage cell_v2 discover_hosts --verbose</code></p>
<h2 id="8-安装卷服务CINDER（可选）"><a href="#8-安装卷服务CINDER（可选）" class="headerlink" title="8.安装卷服务CINDER（可选）"></a>8.安装卷服务CINDER（可选）</h2><p>在控制节点格式化一个lvm的盘sdb1, 如果不是sdb1, 需要修改&#x2F;root&#x2F;openstack-install&#x2F;openstack&#x2F;cinder.sh脚本对应内容<br>进入&#x2F;root&#x2F;openstack-instal&#x2F;openstack目录, 执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source variable.sh</span><br><span class="line">source openstack-rc</span><br><span class="line">./cinder.sh</span><br></pre></td></tr></table></figure>


<p>sudo apt-get install -y git-email<br>sudo apt-get install -y libaio-dev libbluetooth-dev libcapstone-dev libbrlapi-dev libbz2-dev<br>sudo apt-get install -y libcap-ng-dev libcurl4-gnutls-dev libgtk-3-dev<br>sudo apt-get install -y libibverbs-dev libjpeg8-dev libncurses5-dev libnuma-dev<br>sudo apt-get install -y librbd-dev librdmacm-dev<br>sudo apt-get install -y libsasl2-dev libsdl2-dev libseccomp-dev libsnappy-dev libssh-dev<br>sudo apt-get install -y libvde-dev libvdeplug-dev libvte-2.91-dev libxen-dev liblzo2-dev<br>sudo apt-get install -y valgrind xfslibs-dev </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://github.com/2025/08/21/%E6%9C%89%E5%85%B3%E5%9C%A83A5000%E4%B8%8A%E5%90%AF%E5%8A%A8android%E5%9B%BE%E5%BD%A2%E6%A0%88%E7%9A%84%E5%87%A0%E7%82%B9%E8%AF%B4%E6%98%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dz">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog of dz">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | blog of dz">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/21/%E6%9C%89%E5%85%B3%E5%9C%A83A5000%E4%B8%8A%E5%90%AF%E5%8A%A8android%E5%9B%BE%E5%BD%A2%E6%A0%88%E7%9A%84%E5%87%A0%E7%82%B9%E8%AF%B4%E6%98%8E/" class="post-title-link" itemprop="url">Android在3A5000上启动图形栈说明</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-21 19:04:06" itemprop="dateCreated datePublished" datetime="2025-08-21T19:04:06+08:00">2025-08-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-硬件准备"><a href="#1-硬件准备" class="headerlink" title="1.硬件准备"></a>1.硬件准备</h1><p>3A5000测试机，Radeon 520OEM显卡,串口用于连接3A5000测试机以及工作机（串口软件minicom或者picocom），HDMI线连接显卡和显示器（VGA线暂时不支持）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">loongson@loongson-pc:~$ lspci -v -s 06:00.0</span><br><span class="line">06:00.0 VGA compatible controller: Advanced Micro Devices, Inc. [AMD/ATI] Oland [Radeon HD 8570 / R5 430 OEM / R7 240/340 / Radeon 520 OEM] (rev 87) (prog-if 00 [VGA controller])</span><br><span class="line">        Subsystem: Bitland(ShenZhen) Information Technology Co., Ltd. Radeon 520 OEM</span><br><span class="line">        Flags: bus master, fast devsel, latency 0, IRQ 48, NUMA node 0</span><br><span class="line">        Memory at e0030000000 (64-bit, prefetchable) [size=256M]</span><br><span class="line">        Memory at e0041000000 (64-bit, non-prefetchable) [size=256K]</span><br><span class="line">        I/O ports at 4000 [size=256]</span><br><span class="line">        Expansion ROM at e0041040000 [disabled] [size=128K]</span><br><span class="line">        Capabilities: &lt;access denied&gt;</span><br><span class="line">        Kernel driver in use: radeon</span><br><span class="line">        Kernel modules: radeon, amdgpu</span><br></pre></td></tr></table></figure>
<h1 id="2-硬盘分区及相关配置说明"><a href="#2-硬盘分区及相关配置说明" class="headerlink" title="2.硬盘分区及相关配置说明"></a>2.硬盘分区及相关配置说明</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">loongson@loongson-pc:~$ sudo gdisk</span><br><span class="line">GPT fdisk (gdisk) version 1.0.3</span><br><span class="line"></span><br><span class="line">Type device filename, or press &lt;Enter&gt; to exit: /dev/sda</span><br><span class="line">Partition table scan:</span><br><span class="line">  MBR: protective</span><br><span class="line">  BSD: not present</span><br><span class="line">  APM: not present</span><br><span class="line">  GPT: present</span><br><span class="line"></span><br><span class="line">Found valid GPT with protective MBR; using GPT.</span><br><span class="line"></span><br><span class="line">Command (? for help): p</span><br><span class="line">Disk /dev/sda: 500118192 sectors, 238.5 GiB</span><br><span class="line">Model: YMTC SC001-256GB</span><br><span class="line">Sector size (logical/physical): 512/512 bytes</span><br><span class="line">Disk identifier (GUID): D647FC08-8976-4385-A183-BB1F67ACB5DA</span><br><span class="line">Partition table holds up to 128 entries</span><br><span class="line">Main partition table begins at sector 2 and ends at sector 33</span><br><span class="line">First usable sector is 34, last usable sector is 500118158</span><br><span class="line">Partitions will be aligned on 2-sector boundaries</span><br><span class="line">Total free space is 146565775 sectors (69.9 GiB)</span><br><span class="line"></span><br><span class="line">Number  Start (sector)    End (sector)  Size       Code  Name</span><br><span class="line">   1              34          616447   301.0 MiB   0700  </span><br><span class="line">   2          616448         1230847   300.0 MiB   8300  </span><br><span class="line">   3         1230848       282249215   134.0 GiB   8300  </span><br><span class="line">   4       282249216       315803647   16.0 GiB    8200  </span><br><span class="line">   5       315803648       336775167   10.0 GiB    8300  super</span><br><span class="line">   6       336775168       345163775   4.0 GiB     8300  data</span><br><span class="line">   7       345163776       349358079   2.0 GiB     8300  cache</span><br><span class="line">   8       349358080       351455231   1024.0 MiB  8300  metadata</span><br><span class="line">   9       351455232       353552383   1024.0 MiB  8300  boot</span><br></pre></td></tr></table></figure>
<p>这里为了方便调试我采用的是双系统方案，硬盘分区格式是gpt格式，其中分区1-4是loongnix系统，分区5-8分别是安卓的super,data,cache,metadata分区，分区9用来放置内核和ramdisk等一些启动程序。<br>需要注意的是，goldfish中的fstab.ranchu的分区需要与上述分区一致,由下可见</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Android fstab file.</span><br><span class="line">#&lt;dev&gt;  &lt;mnt_point&gt; &lt;type&gt;  &lt;mnt_flags options&gt; &lt;fs_mgr_flags&gt;</span><br><span class="line">system   /system     ext4    ro,barrier=1     wait,logical,first_stage_mount</span><br><span class="line">vendor   /vendor     ext4    ro,barrier=1     wait,logical,first_stage_mount</span><br><span class="line">/dev/block/sda6 /data     ext4      noatime,nosuid,nodev,nomblk_io_submit,errors=panic   wait,check,quota,fileencryption=aes-256-xts:aes-256-cts,reservedsize=128M,latemount</span><br><span class="line">/dev/block/sda7 /cache ext4      noatime,nosuid,nodev,nomblk_io_submit,errors=panic   wait,check,quota,fileencryption=aes-256-xts:aes-256-cts,reservedsize=128M,latemount</span><br><span class="line">/dev/block/sda8 /metadata    ext4    noatime,nosuid,nodev    wait,formattable,latemount</span><br><span class="line">/dev/block/vdb auto   auto      defaults    voldmanaged=sdcard:auto,encryptable=userdata</span><br><span class="line">/dev/block/zram0 none swap  defaults zramsize=75%</span><br></pre></td></tr></table></figure>
<p>另外在goldfish的init.ranchu-core.sh中可以设置测试机的ip地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/system/bin/ifconfig eth0 up  </span><br><span class="line">/system/bin/ifconfig eth0 192.168.2.2  </span><br><span class="line"> sleep 10  </span><br><span class="line">/system/bin/ip rule add from all lookup main pref 1                                                     </span><br></pre></td></tr></table></figure>
<h1 id="3-烧录"><a href="#3-烧录" class="headerlink" title="3.烧录"></a>3.烧录</h1><p>编译完成后可以使用测试机中的loongnix系统下载源码并烧录<br>这里提供一下烧录脚本，用于从源码所在的服务器或者工作机上把镜像下载到本地并烧录到对应分区</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">server=172.17.103.55 </span><br><span class="line">password=****</span><br><span class="line">username=dongzhe</span><br><span class="line">remote_dir=/home/dongzhe/loongson/aosp.la/out/target/product/generic_loongarch64</span><br><span class="line">image_files=(</span><br><span class="line">        &quot;cache.img&quot;</span><br><span class="line">        &quot;userdata.img&quot;</span><br><span class="line">#        &quot;ramdisk.img&quot;</span><br><span class="line">        &quot;super.img&quot;</span><br><span class="line">#       &quot;vmlinuz.efi&quot;</span><br><span class="line">        )</span><br><span class="line">for file in &quot;$&#123;image_files[@]&#125;&quot;; do</span><br><span class="line">        sshpass -p &quot;$&#123;password&#125;&quot; scp  &quot;$&#123;username&#125;@$&#123;server&#125;:$&#123;remote_dir&#125;/$&#123;file&#125;&quot; ./</span><br><span class="line">        if [ $? -eq 0 ];then</span><br><span class="line">                echo &quot;copy successed: $&#123;file&#125;&quot;</span><br><span class="line">        else</span><br><span class="line">                echo &quot;copy failed: $&#123;file&#125;&quot;</span><br><span class="line">        fi</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">dd if=super.img of=/dev/sda5 bs=32M</span><br><span class="line">dd if=userdata.img of=/dev/sda6 bs=32M</span><br><span class="line">dd if=cache.img of=/dev/sda7 bs=32M</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="4-启动参数"><a href="#4-启动参数" class="headerlink" title="4.启动参数"></a>4.启动参数</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">menuentry &quot;android&quot;&#123;</span><br><span class="line">        linux (hd0,gpt9)/vmlinuz.efi console=ttyS0,115200 norandmaps earlycon enforcing=0 init=/init rw rootfstype=cpio androidboot.selinux=permissive androidboot.hardware=ranchu loglevel=1 androidboot.boot_devices=pci0000:00/0000:00:08.0 printk.devkmsg=on androidboot.verifiedbootstate=orange</span><br><span class="line">        boot</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>boot_devices需与sda所在的pci地址保持一致,采用双系统方案的话可以在装好的loongnix系统中查看硬盘pci地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">loongson@loongson-pc:/sys/block$ realpath sda</span><br><span class="line">/sys/devices/pci0000:00/0000:00:08.0/ata1/host0/target0:0:0/0:0:0:0/block/sda</span><br></pre></td></tr></table></figure>

<p>内核可使用android_qemu_env下的vmlinuz.efi</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://github.com/2025/08/21/%E7%B3%BB%E7%BB%9F%E7%BA%A7%E6%95%85%E9%9A%9C%E6%B3%A8%E5%85%A5%E5%B7%A5%E5%85%B7%E8%B0%83%E7%A0%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dz">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog of dz">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | blog of dz">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/21/%E7%B3%BB%E7%BB%9F%E7%BA%A7%E6%95%85%E9%9A%9C%E6%B3%A8%E5%85%A5%E5%B7%A5%E5%85%B7%E8%B0%83%E7%A0%94/" class="post-title-link" itemprop="url">系统级故障注入工具调研</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-21 19:04:06" itemprop="dateCreated datePublished" datetime="2025-08-21T19:04:06+08:00">2025-08-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为了实现系统可靠性的分析研究，首要解决问题是实现系统的故障注入和性能监测，其中最先需要解决的是工具的调研和使用<br>下列几种linux中常用的系统性能分析工具：</p>
<h2 id="systemtap"><a href="#systemtap" class="headerlink" title="systemtap"></a>systemtap</h2><p>systemtap是利用Kprobe提供的API来实现动态地监控和跟踪运行中的linux内核的工具，经未严谨调研，所需的内核版本要求包括：</p>
<p>基本功能支持:<br>    2.6.9+ - 基本的 Systemtap 工作需要<br>用户空间探针支持(uprobes):<br>    2.6.38+ - 用户函数的跟踪需要该版本以上<br>64位用户空间支持:<br>    2.6.25+ - 支持对应用程序堆栈的64位解析<br>函数跟踪支持(tracepoints):<br>    2.6.32+ - 跟踪内核函数的入口和出口<br>内核函数图支持:<br>    3.x - 提供内核函数调用关系图分析<br>优化的内存访问速度:<br>    4.1+ - 通过直接读写内存提升速度<br>eBPF框架集成:<br>    4.1+ - 可将eBPF程序用于自定义分析</p>
<p>loongnix系统20.5和loongnix-server8.4内核版本均为4.19,高于所需内核版本要求。</p>
<p>systemtap安装需要所需版本的内核信息包，尚未来得及调研，后续会更新<br>    kernel-debuginfo<br>    kernel-debuginfo-common<br>    kernel-devel</p>
<p>systemtap官网：<a target="_blank" rel="noopener" href="https://sourceware.org/systemtap/index.html">https://sourceware.org/systemtap/index.html</a></p>
<h2 id="ebpf"><a href="#ebpf" class="headerlink" title="ebpf"></a>ebpf</h2><p>最近几年在linux系统和性能分析领域较为活跃的主流工具是eBPF(extended Berkeley Packet Filter)。<br>ebpf是一个安全的内核虚拟机，可以用于自定义Tracing和性能分析的内核函数，提供了在特定时间点改变内核或用户空间状态的能力。同上，经不严谨调研：<br>最低基础运行版本:3.18<br>    3.18版本内核引入了对eBPF的基本支持<br>用户空间探针(uprobes): 4.1+<br>    uprobes需要4.1以上内核版本<br>BTF(BPF Type Format):5.1+<br>    BTF用于内核编写和分析的类型元数据,需要5.1以上<br>CO-RE(BPF Ring Buffer): 4.12+<br>    响应式输出缓存环需要4.12以上版本<br>内核函数回调(kprobes): 4.20+<br>    4.20引入bpf_get_stackid等功能以解决lockdep问题<br>内核增强函数(kfunc): 5.6+<br>    kfunc允许无锁定内核函数的bpf程序,需要5.6以上<br>BPF锁定: 4.20+<br>    bpf spin_lock&#x2F;unlock 需要4.20以后版本</p>
<p>某些核心功能内核版本要求高于4.19,实际上由于ebpf技术演进较快，新功能基本都需要新内核的支持，建议采用5.11以上的内核版本。初步判定不适合课题使用，先调研于此。<br>附ebpf官网链接：<a target="_blank" rel="noopener" href="https://ebpf.io/zh-cn/">https://ebpf.io/zh-cn/</a></p>
<p>更：所以 ebpf 实际上是类 Unix 系统上数据链路层的一种原始接口，他可以提供原始链路层包的收发和过滤。</p>
<p>再说简单一点，他就是一个带有过滤功能的数据包收发接口，当然也是可以 dump 数据的。</p>
<p>另外，ebpf 只能读取系统调用的参数和返回值，而不能修改任何寄存器（用户态或者内核态），因此它本身并不具有拦截功能。这一限制实际是其内部 verifier.c 模块的一个部分，真正的目的是为了保证内核本身的运行安全。因此在编写 BPF C 程序时，要非常小心的处理指针操作，避免一切的未定义行为（第5课的实验中会强调）；如果出现了未被 verifier.c 检测出的异常行为，也会在执行时被其他模块中断<br>故：可能不适合作为本次故障注入工具</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://github.com/2025/08/21/%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A42-bash/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dz">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog of dz">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | blog of dz">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/21/%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A42-bash/" class="post-title-link" itemprop="url">常用指令2-bash</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-21 19:04:06" itemprop="dateCreated datePublished" datetime="2025-08-21T19:04:06+08:00">2025-08-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h1><p>find .&#x2F; -type f -name Android.bp -exec cp -R –parents {} <del>&#x2F;mmmmm ;<br>寻找当前目录下文件名为Android.bp的文件并递归保留父文件目录复制到</del>&#x2F;mmmmm目录下
 </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://github.com/2025/08/21/android12%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dz">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog of dz">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | blog of dz">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/21/android12%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">android12启动流程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-21 19:04:06" itemprop="dateCreated datePublished" datetime="2025-08-21T19:04:06+08:00">2025-08-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="android12系统启动流程"><a href="#android12系统启动流程" class="headerlink" title="android12系统启动流程"></a>android12系统启动流程</h1><h2 id="1-启动流程概述"><a href="#1-启动流程概述" class="headerlink" title="1.启动流程概述"></a>1.启动流程概述</h2><h4 id="1-1-Bootloader引导"><a href="#1-1-Bootloader引导" class="headerlink" title="1.1 Bootloader引导"></a>1.1 Bootloader引导</h4><p>当按下设备电源键时，最先运行的就是 bootloader（固化在ROM的程序），bootloader 的主要作用就是硬件设备（如 CPU、flash、内存）的初始化并加载到RAM，通过建立内存空间映射，为装载 Linux 内核做好准备,。如果 bootloader 在运行期间，按下预定义的组合按键，可以进入系统fastboot模式 或者 Receiver 模式。</p>
<h4 id="1-2-装载和启动Linux内核"><a href="#1-2-装载和启动Linux内核" class="headerlink" title="1.2 装载和启动Linux内核"></a>1.2 装载和启动Linux内核</h4><p>在编译完AOSP时会生成boot.img或者boot_debug.img，该镜像就是 Linux 内核和根文件系统，bootloader 会把该镜像装载到内存中，然后 linux 内核会执行整个系统的初始化，完成后装载根文件系统，最后启动 init 进程。</p>
<h4 id="1-3-启动Init进程"><a href="#1-3-启动Init进程" class="headerlink" title="1.3 启动Init进程"></a>1.3 启动Init进程</h4><p>Linux内核加载完毕后，会首先启动Init进程，Init进程是系统的第一个 进程。在Init进程的启动过程中，会解析Linux的配置脚本init.rc文件。根 据init.rc文件的内容，Init进程会装载Android的文件系统、创建系统目 录、初始化属性系统、启动Android系统重要的守护进程，这些进程包括USB 守护进程、adb守护进程、vold守护进程、rild守护进程等。 最后Init进程也会作为守护进程来执行修改属性请求，重启崩溃的进程等操作</p>
<h4 id="1-4-启动ServiceManager"><a href="#1-4-启动ServiceManager" class="headerlink" title="1.4 启动ServiceManager"></a>1.4 启动ServiceManager</h4><p>ServiceManager 由 init 进程启动。它的主要作用是管理 Binder 服务，service 服务的注册和查找，如 AMS、PMS， 都是通过 ServiceManger 来管理。</p>
<h4 id="1-5-启动MediaServer"><a href="#1-5-启动MediaServer" class="headerlink" title="1.5 启动MediaServer"></a>1.5 <strong>启动MediaServer</strong></h4><p>MediaServer 是由 init 进程启动，它包含了一些多媒体 binder 服务，包括 CameraService、MediaPlayerService、AudioPolicyService 等等</p>
<h4 id="1-6启动-Zygote-进程"><a href="#1-6启动-Zygote-进程" class="headerlink" title="1.6启动 Zygote 进程"></a>1.6<strong>启动 Zygote 进程</strong></h4><p>init 进程初始化结束后，会启动 Zygote 进程。在 Android 系统中所有的应用程序进程和系统服务进程都是通过Zygote 进程 fork 出来的。预装载系统的资源文件，所有从 Zygote 进程 fork 出的子进程都会共享这些资源，节省了资源加载的时间，提高的应用的启动速度。Zygote 启动结束后也会变为守护进程，负责响应启动 APK 的请求。</p>
<h4 id="1-7-启动SystemServer"><a href="#1-7-启动SystemServer" class="headerlink" title="1.7 启动SystemServer"></a>1.7 启动SystemServer</h4><p>SystemServer 是 Zygote 进程 fork 出的第一个进程，也是整个 Android 系统的核心进程。在SystemServer中运行着Android系统大部分的 Binder服务。SystemServer首先启动本地服务Sensor Service；接着启动包 括 ActivityManagerService、WindowsMangerService、 PackageManagerService在内的所有Java服务。</p>
<h4 id="1-8-启动Launcher"><a href="#1-8-启动Launcher" class="headerlink" title="1.8 启动Launcher"></a>1.8 启动Launcher</h4><p>SystemServer加载完所有Java服务后，最后会调用 ActivityManagerService的SystemReady()方法。在这个方法的执行中，会发 出Intent“android.intent.category.HOME”。凡是响应这个Intent的apk应 用都会运行起来，Launcher应用是Android系统默认的桌面应用，一般只有它 会响应这个Intent，因此，系统开机后，第一个运行的应用就是Launcher。</p>
<p><img src="/images/android12-init-progress-1.jpg" alt="启动流程概图"></p>
<h3 id="2-启动流程分析"><a href="#2-启动流程分析" class="headerlink" title="2 启动流程分析"></a>2 启动流程分析</h3><p>从代码结构上来看，Android12启动阶段大致可以分为FirstStageMain和SecondStateMain</p>
<h4 id="2-1-编译镜像文件介绍"><a href="#2-1-编译镜像文件介绍" class="headerlink" title="2.1 编译镜像文件介绍"></a>2.1 编译镜像文件介绍</h4><p>AOSP源码编译结束后会生成多个镜像文件，其中有几个重要的镜像文件：</p>
<table>
<thead>
<tr>
<th>镜像</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>ramdisk.img</td>
<td>根文件系统镜像，包含一些启动Android系统的重要文件，如init.rc等，挂载点是&#x2F;</td>
</tr>
<tr>
<td>boot.img</td>
<td>包含kernel+ramdisk.img</td>
</tr>
<tr>
<td>userdata.img</td>
<td>挂载点&#x2F;data，包含了用户的所有数据，例如应用数据等</td>
</tr>
<tr>
<td>system.img</td>
<td>系统镜像，里面包含了Android系统主要的目录和文件，通过init.rc进行解析并挂载到&#x2F;system目录下</td>
</tr>
<tr>
<td>super.img</td>
<td>Android10以后引入的动态分区结构，为了解决system和vender等分区size不能动态调整的问题</td>
</tr>
</tbody></table>
<p>这里仅作简单了解。</p>
<h4 id="2-2-init进程分析"><a href="#2-2-init进程分析" class="headerlink" title="2.2 init进程分析"></a>2.2 init进程分析</h4><p>在bootloader引导以及linux内核装载启动完成后，会启动init进程，在目录</p>
<p>$AOSP&#x2F;system&#x2F;core&#x2F;init&#x2F;main.cpp下，执行init进程的启动流程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace android::init;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv) &#123;//内核层传递的参数,argc:1,argv:init</span><br><span class="line">#if __has_feature(address_sanitizer)</span><br><span class="line">    __asan_set_error_report_callback(AsanReportCallback);</span><br><span class="line">#endif</span><br><span class="line">    // Boost prio which will be restored later</span><br><span class="line">    setpriority(PRIO_PROCESS, 0, -20);//设置进程最高优先级 -20最高，20最低</span><br><span class="line">    if (!strcmp(basename(argv[0]), &quot;ueventd&quot;)) &#123;</span><br><span class="line">        return ueventd_main(argc, argv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (argc &gt; 1) &#123;</span><br><span class="line">        if (!strcmp(argv[1], &quot;subcontext&quot;)) &#123;</span><br><span class="line">            android::base::InitLogging(argv, &amp;android::base::KernelLogger);</span><br><span class="line">            const BuiltinFunctionMap&amp; function_map = GetBuiltinFunctionMap();</span><br><span class="line"></span><br><span class="line">            return SubcontextMain(argc, argv, &amp;function_map);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!strcmp(argv[1], &quot;selinux_setup&quot;)) &#123;</span><br><span class="line">            return SetupSelinux(argv);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!strcmp(argv[1], &quot;second_stage&quot;)) &#123;</span><br><span class="line">            return SecondStageMain(argc, argv);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return FirstStageMain(argc, argv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (argc &gt; 1) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">return FirstStageMain(argc, argv);</span><br></pre></td></tr></table></figure>

<p>这段代码包含了init&#x2F;main.cpp需要执行的几个阶段，在几个子阶段执行结束之后会重新调用init&#x2F;main.cpp以进入其他分支，如在FirstStageMain中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const char* path = &quot;/system/bin/init&quot;;</span><br><span class="line">    const char* args[] = &#123;path, &quot;selinux_setup&quot;, nullptr&#125;;</span><br><span class="line">    auto fd = open(&quot;/dev/kmsg&quot;, O_WRONLY | O_CLOEXEC);</span><br><span class="line">    dup2(fd, STDOUT_FILENO);</span><br><span class="line">    dup2(fd, STDERR_FILENO);</span><br><span class="line">    close(fd);</span><br><span class="line">    execv(path, const_cast&lt;char**&gt;(args));</span><br></pre></td></tr></table></figure>

<p>会重新调用&#x2F;system&#x2F;bin&#x2F;init（init模块编译后的挂载地址），并传递参数selinux_setup以启动下一个阶段</p>
<h4 id="2-3-FirstStageMain-int-argc-char-argv"><a href="#2-3-FirstStageMain-int-argc-char-argv" class="headerlink" title="2.3 FirstStageMain(int argc, char** argv)"></a>2.3 FirstStageMain(int argc, char** argv)</h4><p>$AOSP&#x2F;system&#x2F;core&#x2F;init&#x2F;first_stage_init.cpp</p>
<p>该阶段所挂载的文件系统都属于ramdisk，运行在虚拟内存上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line">int FirstStageMain(int argc, char** argv) &#123;</span><br><span class="line">    // init阶段的启动引导加载程序（bootLoader），若发生异常重启也会再次执行，主要处理init || fork的子进程进程异常行为</span><br><span class="line">    // init信号处理器，调试版本当init crash，默认重启到 bootLoader</span><br><span class="line">    if (REBOOT_BOOTLOADER_ON_PANIC) &#123;</span><br><span class="line">        InstallRebootSignalHandlers();// setup1</span><br><span class="line">    &#125;</span><br><span class="line">    // 用来设置创建目录或文件时所应该赋予权限的掩码</span><br><span class="line">    // Linux中，文件默认最大权限是666，目录最大权限是777，当创建目录时，假设掩码为022，那赋予它的权限为（777 &amp; ~022）= 755</span><br><span class="line">    // 在执行init第一阶段时，先执行umask(0)，使创建的目录或文件的默认权限为最高</span><br><span class="line">    umask(0);</span><br><span class="line"></span><br><span class="line">    // 第一次执行时清除环境变量，reset path</span><br><span class="line">    CHECKCALL(clearenv());</span><br><span class="line">    CHECKCALL(setenv(&quot;PATH&quot;, _PATH_DEFPATH, 1));</span><br><span class="line">    // setup 2</span><br><span class="line">    // 设置linux最基本的文件系统并且挂载到 / 目录(init ram disk)上,</span><br><span class="line">    // 并给0755权限（即用户具有读/写/执行权限，组用户和其它用户具有读写权限），后续会通过rc文件处理一些分区权限和进程</span><br><span class="line">    CHECKCALL(mount(&quot;tmpfs&quot;, &quot;/dev&quot;, &quot;tmpfs&quot;, MS_NOSUID, &quot;mode=0755&quot;)); //将/dev设置为tmpfs并挂载，设置0755权限，tmpfs是在内存上建立的文件系统（Filesystem）</span><br><span class="line">    CHECKCALL(mkdir(&quot;/dev/pts&quot;, 0755));//tmpfs文件系统类型</span><br><span class="line">    CHECKCALL(mkdir(&quot;/dev/socket&quot;, 0755));</span><br><span class="line">    CHECKCALL(mkdir(&quot;/dev/dm-user&quot;, 0755));//tmpfs文件系统类型</span><br><span class="line">    CHECKCALL(mount(&quot;devpts&quot;, &quot;/dev/pts&quot;, &quot;devpts&quot;, 0, NULL));</span><br><span class="line">    // setup 3</span><br><span class="line"> 	CHECKCALL(mount(&quot;proc&quot;, &quot;/proc&quot;, &quot;proc&quot;, 0, &quot;hidepid=2,gid=&quot; MAKE_STR(AID_READPROC)));</span><br><span class="line">#undef MAKE_STR</span><br><span class="line">    // 修改 「保存操作系统的启动参数」 的权限：0440，</span><br><span class="line">    // 修改权限的目的是为了 不要将原始bootConfig暴露给非特权进程，部分文件系统只能是0440权限，如果修改权限则无法读取和操作</span><br><span class="line">    // /proc/cmdline中保存bootloader 启动linux kernel 时 的参数</span><br><span class="line">    CHECKCALL(chmod(&quot;/proc/cmdline&quot;, 0440));</span><br><span class="line">    std::string cmdline;</span><br><span class="line">    // 读取操作系统的启动参数</span><br><span class="line">    android::base::ReadFileToString(&quot;/proc/cmdline&quot;, &amp;cmdline);</span><br><span class="line">    // 修改权限的目的是为了 不要将原始bootConfig暴露给非特权进程</span><br><span class="line">    // 部分文件系统只能是0440权限，如果修改权限则无法读取和操作</span><br><span class="line">    chmod(&quot;/proc/bootconfig&quot;, 0440);</span><br><span class="line">    std::string bootconfig;</span><br><span class="line">    // 读取系统启动参数配置</span><br><span class="line">    android::base::ReadFileToString(&quot;/proc/bootconfig&quot;, &amp;bootconfig);</span><br><span class="line">    gid_t groups[] = &#123;AID_READPROC&#125;;</span><br><span class="line">    CHECKCALL(setgroups(arraysize(groups), groups));</span><br><span class="line">    // setup 4</span><br><span class="line">    // 挂载/sys内核,并设置为sysfs文件系统类型，sysfs是一个伪文件系统。</span><br><span class="line">    // 不代表真实的物理设备，在linux内核中，sysfs文件系统将长期存在于RAM中</span><br><span class="line">    // sysfs文件系统将每个设备抽象成文件,挂载sysfs文件系统在sys目录，用来访问内核信息</span><br><span class="line">    CHECKCALL(mount(&quot;sysfs&quot;, &quot;/sys&quot;, &quot;sysfs&quot;, 0, NULL));</span><br><span class="line">    CHECKCALL(mount(&quot;selinuxfs&quot;, &quot;/sys/fs/selinux&quot;, &quot;selinuxfs&quot;, 0, NULL));</span><br><span class="line">    CHECKCALL(mknod(&quot;/dev/kmsg&quot;, S_IFCHR | 0600, makedev(1, 11)));</span><br><span class="line">    if constexpr (WORLD_WRITABLE_KMSG) &#123;</span><br><span class="line">        CHECKCALL(mknod(&quot;/dev/kmsg_debug&quot;, S_IFCHR | 0622, makedev(1, 11)));</span><br><span class="line">    &#125;</span><br><span class="line">    // 文件系统：/dev/random和 /dev/urandom是 Linux 上的字符设备文件，它们是随机数生成器，为系统提供随机数</span><br><span class="line">    CHECKCALL(mknod(&quot;/dev/random&quot;, S_IFCHR | 0666, makedev(1, 8)));</span><br><span class="line">    CHECKCALL(mknod(&quot;/dev/urandom&quot;, S_IFCHR | 0666, makedev(1, 9)));</span><br><span class="line">    </span><br><span class="line">    // 创建日志系统的串口log(伪终端),这是日志包装器所需要的，它在ueventd运行之前被调用。</span><br><span class="line">    CHECKCALL(mknod(&quot;/dev/ptmx&quot;, S_IFCHR | 0666, makedev(5, 2)));</span><br><span class="line">    CHECKCALL(mknod(&quot;/dev/null&quot;, S_IFCHR | 0666, makedev(1, 3)));</span><br><span class="line">    </span><br><span class="line">    // setup 5</span><br><span class="line">    // 重要文件系统及分区在第一阶段挂载，其他可以在rc执行流程中挂载</span><br><span class="line">    // 挂载/mnt/&#123;vendor,product&#125;，这些相对比较重要，所以只挂载重要的，其余的动作会在第二阶段的解析rc文件中处理</span><br><span class="line">    // tmpfs之前说过了，是运作在RAM的文件系统</span><br><span class="line">    CHECKCALL(mount(&quot;tmpfs&quot;, &quot;/mnt&quot;, &quot;tmpfs&quot;, MS_NOEXEC | MS_NOSUID | MS_NODEV,</span><br><span class="line">                    &quot;mode=0755,uid=0,gid=1000&quot;));</span><br><span class="line">    CHECKCALL(mkdir(&quot;/mnt/vendor&quot;, 0755));</span><br><span class="line">    CHECKCALL(mkdir(&quot;/mnt/product&quot;, 0755));</span><br><span class="line">    CHECKCALL(mount(&quot;tmpfs&quot;, &quot;/debug_ramdisk&quot;, &quot;tmpfs&quot;, MS_NOEXEC | MS_NOSUID | MS_NODEV,</span><br><span class="line">                    &quot;mode=0755,uid=0,gid=0&quot;));</span><br><span class="line">    // 创建selinux驱动节点，类型属于：tmpfs</span><br><span class="line">    CHECKCALL(mkdir(&quot;/dev/selinux&quot;, 0744));</span><br><span class="line">    // 初始化kernel的日志，之前已经创建过了/dev/kmsg系统，用于处理日志的</span><br><span class="line">    SetStdioToDevNull(argv);</span><br><span class="line">    InitKernelLogging(argv);</span><br><span class="line">    // log可以使用了，第一阶段正式开始 创建设备</span><br><span class="line">    LOG(INFO) &lt;&lt; &quot;init first stage started!&quot;;</span><br><span class="line">    // setup 6</span><br><span class="line">    // 打开根目录 / ，隶属ramdisk,就是上面挂载的基本文件系统</span><br><span class="line">    auto old_root_dir = std::unique_ptr&lt;DIR, decltype(&amp;closedir)&gt;&#123;opendir(&quot;/&quot;), closedir&#125;;</span><br><span class="line">    // 用stat函数获取根目录的文件信息给（old_root_info），例如访问的时间，修改的时间，目录下的文件数量</span><br><span class="line">    // 若！=0则是获取失败，提示未释放ramdisk,估计是基本文件系统还未处理完成</span><br><span class="line">    if (stat(&quot;/&quot;, &amp;old_root_info) != 0) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; &quot;Could not stat(\&quot;/\&quot;), not freeing ramdisk&quot;;</span><br><span class="line">        old_root_dir.reset();</span><br><span class="line">    &#125;</span><br><span class="line">    // 加载kernel模块且是非正常的启动模式</span><br><span class="line">    // 根据ALLOW_FIRST_STAGE_CONSOLE(want_console)决定是否打开串口log(控制台log)，并加载kernel模块且处于非正常的启动模式</span><br><span class="line">    // 再根据want_console来决定是否打开串口日志</span><br><span class="line">    if (!LoadKernelModules(IsRecoveryMode() &amp;&amp; !ForceNormalBoot(cmdline, bootconfig), want_console,</span><br><span class="line">                           want_parallel, module_count)) &#123;</span><br><span class="line">        if (want_console != FirstStageConsoleParam::DISABLED) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; &quot;Failed to load kernel modules, starting console&quot;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            LOG(FATAL) &lt;&lt; &quot;Failed to load kernel modules&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 继续根据是否打开串口日志来创建devices</span><br><span class="line">    // want_console == 1</span><br><span class="line">    if (want_console == FirstStageConsoleParam::CONSOLE_ON_FAILURE) &#123;</span><br><span class="line">    	 // 非恢复模式下进行，在 recovery 模式下不允许创建设备</span><br><span class="line">        if (!IsRecoveryMode()) &#123;</span><br><span class="line">            // 在创建逻辑分区之前挂载 /metadata</span><br><span class="line">            // metadata.img和userdata.img密切相连，metadata存放了一把Primary key，如果没有这个key，userdata数据不能访问</span><br><span class="line">            // 在工作时可能需要单独刷分区来验证问题，所以有时候不能单独刷metadata分区</span><br><span class="line">            created_devices = DoCreateDevices();</span><br><span class="line">            if (!created_devices) &#123;</span><br><span class="line">                LOG(ERROR) &lt;&lt; &quot;Failed to create device nodes early&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StartConsole(cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">    // setup 7</span><br><span class="line">    // 当build.prop具有访问权限时，主要就是生成/second_stage_resources/system/etc/ramdisk/build.prop</span><br><span class="line">    // 将/system/etc/ramdisk/build.prop拷贝到/second_stage_resources/system/etc/ramdisk下</span><br><span class="line">    if (access(kBootImageRamdiskProp, F_OK) == 0) &#123;</span><br><span class="line">        // 获取/second_stage_resources/system/etc/ramdisk/build.prop</span><br><span class="line">        // 当然此时这个目录没有创建，只是一个拼接出来的路径，后续会创建</span><br><span class="line">        std::string dest = GetRamdiskPropForSecondStage();</span><br><span class="line">         // 获取目录路径名称 ： /second_stage_resources/system/etc/ramdisk</span><br><span class="line">        std::string dir = android::base::Dirname(dest);</span><br><span class="line">        std::error_code ec;</span><br><span class="line">        if (!fs::create_directories(dir, ec) &amp;&amp; !!ec) &#123;</span><br><span class="line">            LOG(FATAL) &lt;&lt; &quot;Can&#x27;t mkdir &quot; &lt;&lt; dir &lt;&lt; &quot;: &quot; &lt;&lt; ec.message();</span><br><span class="line">        &#125;</span><br><span class="line">        // 生成 /second_stage_resources/system/etc/ramdisk/build.prop</span><br><span class="line">        if (!fs::copy_file(kBootImageRamdiskProp, dest, ec)) &#123;</span><br><span class="line">            LOG(FATAL) &lt;&lt; &quot;Can&#x27;t copy &quot; &lt;&lt; kBootImageRamdiskProp &lt;&lt; &quot; to &quot; &lt;&lt; dest &lt;&lt; &quot;: &quot;</span><br><span class="line">                       &lt;&lt; ec.message();</span><br><span class="line">        &#125;</span><br><span class="line">        LOG(INFO) &lt;&lt; &quot;Copied ramdisk prop to &quot; &lt;&lt; dest;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果存在“/force_debugable”，则第二阶段init将使用userdebug sepolicy并加载adb_debug.prop以允许adb root</span><br><span class="line">    // /userdebug_plat_sepolicy.cil属于selinux策略里的规则</span><br><span class="line">    // 如果设备unlocked（解锁了），则会修改selinux规则，放大用户权限</span><br><span class="line">    if (access(&quot;/force_debuggable&quot;, F_OK) == 0) &#123;</span><br><span class="line">        constexpr const char adb_debug_prop_src[] = &quot;/adb_debug.prop&quot;;</span><br><span class="line">        constexpr const char userdebug_plat_sepolicy_cil_src[] = &quot;/userdebug_plat_sepolicy.cil&quot;;</span><br><span class="line">        ...</span><br><span class="line">        setenv(&quot;INIT_FORCE_DEBUGGABLE&quot;, &quot;true&quot;, 1);</span><br><span class="line">    &#125;</span><br><span class="line">    // setup 8</span><br><span class="line">    // 如果内核命令行中存在 androidboot.force_normal_boot=1，则设备会正常启动，即正常启动时</span><br><span class="line">    if (ForceNormalBoot(cmdline, bootconfig)) &#123;</span><br><span class="line">        // 创建第一阶段ramdisk目录 /first_stage_ramdisk</span><br><span class="line">        mkdir(&quot;/first_stage_ramdisk&quot;, 0755);</span><br><span class="line">        // 提前创建 &quot;/system/bin/snapuserd&quot; &amp;&amp; &quot;/first_stage_ramdisk/system/bin/snapuserd&quot;;</span><br><span class="line">        PrepareSwitchRoot();</span><br><span class="line">        if (mount(&quot;/first_stage_ramdisk&quot;, &quot;/first_stage_ramdisk&quot;, nullptr, MS_BIND, nullptr) != 0) &#123;</span><br><span class="line">            PLOG(FATAL) &lt;&lt; &quot;Could not bind mount /first_stage_ramdisk to itself&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        // 将根目录（/）切换为 /first_stage_ramdisk ，将根切换到 first_stage_ramdisk</span><br><span class="line">        SwitchRoot(&quot;/first_stage_ramdisk&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	// 挂载 system、vendor 、product等系统分区</span><br><span class="line">    if (!DoFirstStageMount(!created_devices)) &#123;</span><br><span class="line">        LOG(FATAL) &lt;&lt; &quot;Failed to mount required partitions early ...&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    // 此时new_root_info应该是 /first_stage_ramdisk,而old_root_info是 /root</span><br><span class="line">    // 读取 /first_stage_ramdisk根目录信息，例如有多少个目录等</span><br><span class="line">    struct stat new_root_info;</span><br><span class="line">    if (stat(&quot;/&quot;, &amp;new_root_info) != 0) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; &quot;Could not stat(\&quot;/\&quot;), not freeing ramdisk&quot;;</span><br><span class="line">        old_root_dir.reset();</span><br><span class="line">    &#125;</span><br><span class="line">    // 根目录发生变化，则释放old ramdisk，用new ramdisk</span><br><span class="line">    if (old_root_dir &amp;&amp; old_root_info.st_dev != new_root_info.st_dev) &#123;</span><br><span class="line">        FreeRamdisk(old_root_dir.get(), old_root_info.st_dev);</span><br><span class="line">    &#125;</span><br><span class="line">    // setup 8 主要内容:将根目录（/）切换为 /first_stage_ramdisk ，将根切换到 first_stage_ramdisk</span><br><span class="line">    // setup 9</span><br><span class="line">    //初始化安全框架 Android Verified Boot，用于防止系统文件本身被篡改、防止系统回滚，以免回滚系统利用以前的漏洞。</span><br><span class="line">    // 包括Secure Boot, verified boot 和 dm-verity（会校验只读分区大小，若只读分区二进制改变则可能上被串改了，例如 user强制root）,</span><br><span class="line">    // 原理都是对二进制文件进行签名，在系统启动时进行认证，确保系统运行的是合法的二进制镜像文件。其中认证的范围涵盖：bootloader，boot.img，system.img。</span><br><span class="line">    // 此处是在recovery模式下初始化avb的版本，不是recovery模式直接跳过</span><br><span class="line">    SetInitAvbVersionInRecovery();</span><br><span class="line">    // setup 10 ---&gt;主要开始进入下一个阶段了，即当期阶段结束了</span><br><span class="line">    // init程序的二进制文件目录</span><br><span class="line">    const char* path = &quot;/system/bin/init&quot;;</span><br><span class="line">    const char* args[] = &#123;path, &quot;selinux_setup&quot;, nullptr&#125;; // 设置args为selinux_setup，又重新执行回到main.cpp中，执行SetupSelinux</span><br><span class="line">    auto fd = open(&quot;/dev/kmsg&quot;, O_WRONLY | O_CLOEXEC);// 打开日志处理分区</span><br><span class="line">    // exec系列函数可以把当前进程替换为一个新进程，且新进程与原进程有相同的PID，即重新回到main.cpp</span><br><span class="line">    execv(path, const_cast&lt;char**&gt;(args));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>具体的代码细节不做进一步研究，仅作功能上的描述。FirstStageMain可分为10部分：</p>
<p>set1:引导加载程序，处理异常行为</p>
<p>set2:初始化文件系统tmpfs</p>
<p>set3:修改&#x2F;proc目录权限并读取操作系统启动参数</p>
<p>set4:创建sysfs,kmsg,&#x2F;dev&#x2F;null等设备文件</p>
<p>set5:创建vendor,product,mnt等较为重要的分区</p>
<p>set6:打开串口log(可设置是否打开<em>want_console</em>)</p>
<p>set7:获取ramdisk下的prop属性值并为第二阶段准备</p>
<p>set8:创建 &#x2F;first_stage_ramdisk目录作为根目录并切换，以降低权限</p>
<p>set9:fstab和是否支持AVB2.0相关的处理</p>
<p>set10:SetupSelinux</p>
<h4 id="2-4-SetupSelinux-char-argv"><a href="#2-4-SetupSelinux-char-argv" class="headerlink" title="2.4 SetupSelinux(char** argv)"></a>2.4 SetupSelinux(char** argv)</h4><p>$AOSP&#x2F;system&#x2F;core&#x2F;init&#x2F;selinux.cpp</p>
<p>SeLinux 全称 Security-Enhanced Linux 即安全增强型 Linux，基于MAC机制的一种实现，它是一个 Linux  内核模块，也是 Linux 的一个安全子系统，这不是android特有的特性，而是由Linux衍生过来的SEAndroid。具体的代码细节不再关注，关注一下selinux修改权限的方法：</p>
<p><strong>SELinux 分为 Permissive 和 Enforcing 两种模式</strong></p>
<p>Permissive 宽容模式<br>宽容模式，代表 SELinux 运作中，违反 SELinux 规则时只会有警告讯息（avc denied），而不会实际限制的访问.<br>在 Permissive 模式中，SELinux 被启用，但安全策略规则并没有被强制执行。当安全策略规则应该拒绝访问时，访问仍然被允许。然而，此时会向日志文件发送一条消息，表示该访问应该被拒绝（avc）.</p>
<p>Enforcing 严格模式<br>在 Enforcing 模式中， SELinux 被启动，并强制执行所有的安全策略规则，代表 SELinux 运作中，违反 SELinux 规则的行为将被阻止并记录到日志中(avc)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb shell getenforce	//查看当前SELinux模式</span><br><span class="line">adb shell setenforce 0 //设置为Permissive宽松模式，临时关闭SELinux，机器重启以后还是会恢复的</span><br></pre></td></tr></table></figure>

<h4 id="2-5-SecondStageMain-int-argc-char-argv"><a href="#2-5-SecondStageMain-int-argc-char-argv" class="headerlink" title="2.5 SecondStageMain(int argc, char** argv)"></a>2.5 SecondStageMain(int argc, char** argv)</h4><p>$AOSP&#x2F;system&#x2F;core&#x2F;init&#x2F;init.cpp&#x2F;SecondStageMain(int argc, char** argv)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line">int SecondStageMain(int argc, char** argv) &#123;</span><br><span class="line">    if (REBOOT_BOOTLOADER_ON_PANIC) &#123;</span><br><span class="line">        // 针对产生异常的进程进行信号处理,确保子进程能重启，如果主进程pid=1发生异常则触发crash</span><br><span class="line">        // 已经在上个文章分析过该函数</span><br><span class="line">        InstallRebootSignalHandlers();</span><br><span class="line">    &#125;</span><br><span class="line"> 	...</span><br><span class="line">    // 初始化kernel log,所有的kernel log均输出在/dev/kmsg设备节点上</span><br><span class="line">    SetStdioToDevNull(argv);</span><br><span class="line">    InitKernelLogging(argv);</span><br><span class="line">    LOG(INFO) &lt;&lt; &quot;init second stage started!&quot;;</span><br><span class="line">    ...</span><br><span class="line">    // Init不应该因为依赖于任何其他进程而崩溃，因此我们忽略主进程的信号管道信息</span><br><span class="line">    // 但我们不想忽略子进程的SIGPIPE（信号管道），因此我们为信号处理程序设置了一个no op函数</span><br><span class="line">    // SIGPIPE信号产生的场景举例</span><br><span class="line">    // ① 初始时，C、S连接建立，若某一时刻，C端进程宕机或者被KILL而终止（终止的C端进程将会关闭打开的文件描述符，即向S端发送FIN段），S端收到FIN后，响应ACK</span><br><span class="line">    // ② 假设此时，S端仍然向C端发送数据：当第一次写数据后，S端将会收到RST分节； 当收到RST分节后，第二次写数据后，S端将收到SIGPIPE信号（S端进程被终止）</span><br><span class="line">    &#123;</span><br><span class="line">        struct sigaction action = &#123;.sa_flags = SA_RESTART&#125;;</span><br><span class="line">        action.sa_handler = [](int) &#123;&#125;;</span><br><span class="line">        // sigaction是一个函数，可以用来查询或设置信号处理方式</span><br><span class="line">        sigaction(SIGPIPE, &amp;action, nullptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //  MIN_OOM_SCORE_ADJUST = -1000;</span><br><span class="line">    //  MAX_OOM_SCORE_ADJUST = 1000;</span><br><span class="line">    //  设置进程的优先级，例如APK优先级是AMS计算出来并下发到/proc/1/oom_score_adj</span><br><span class="line">    //  统一由init进程设置/proc/**/oom_score_adj为-1000优先级</span><br><span class="line">    if (auto result =</span><br><span class="line">                WriteFile(&quot;/proc/1/oom_score_adj&quot;, StringPrintf(&quot;%d&quot;, DEFAULT_OOM_SCORE_ADJUST));</span><br><span class="line">        !result.ok()) &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; &quot;Unable to write &quot; &lt;&lt; DEFAULT_OOM_SCORE_ADJUST</span><br><span class="line">                   &lt;&lt; &quot; to /proc/1/oom_score_adj: &quot; &lt;&lt; result.error();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	...</span><br><span class="line">    // 创建 /dev/.booting 文件，就是个标记，表示booting进行中</span><br><span class="line">    // is_booting()函数会依靠空文件&quot;.booting&quot;来判断是否进程处于初始化中，初始化结束后，这个文件会被删除</span><br><span class="line">    close(open(&quot;/dev/.booting&quot;, O_WRONLY | O_CREAT | O_CLOEXEC, 0000));</span><br><span class="line">    </span><br><span class="line">    // 当设备解锁时，允许adb root</span><br><span class="line">    // 如果设备unlocked（解锁了），则会修改selinux规则，放大用户权限,这一点在第一阶段已经完成了</span><br><span class="line">    // 并设置了INIT_FORCE_DEBUGGABLE环境变量，这里只是根据环境变量获取第一阶段的内容</span><br><span class="line">    const char* force_debuggable_env = getenv(&quot;INIT_FORCE_DEBUGGABLE&quot;);</span><br><span class="line">    bool load_debug_prop = false;</span><br><span class="line">    if (force_debuggable_env &amp;&amp; AvbHandle::IsDeviceUnlocked()) &#123;</span><br><span class="line">        load_debug_prop = &quot;true&quot;s == force_debuggable_env;</span><br><span class="line">    &#125;</span><br><span class="line">    unsetenv(&quot;INIT_FORCE_DEBUGGABLE&quot;);</span><br><span class="line">    </span><br><span class="line">    // 如果设备未unlock，则卸载关于debug版本的/debug_ramdisk</span><br><span class="line">    // 让属性值读取/ramdisk而不是/debug_ramdisk，因为非unlock,不需要debug ramdisk</span><br><span class="line">    if (!load_debug_prop) &#123;</span><br><span class="line">    	// setup 1</span><br><span class="line">        UmountDebugRamdisk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 初始化属性服务</span><br><span class="line">    // 获取system/build.prop,vendor/build.prop,/odm/build.prop,/product/build.prop,等其他build.prop并加载到properties map结构中</span><br><span class="line">    // 然后会将该properties结构，通过MMAP映射到全局内存中，供所有进程调用，主要ro是只读，只能够写一次，即初始化时给的一次值</span><br><span class="line">    // 注意build.prop有优先级，product下的优先级最高，因为是map结构，针对key相同的属性值时，会覆盖</span><br><span class="line">    // setup 2</span><br><span class="line">    PropertyInit();</span><br><span class="line"></span><br><span class="line">    // Umount second stage resources after property service has read the .prop files.</span><br><span class="line">    // 在属性服务读取.prop文件后，将卸载/second_stage_resources，因为已经用不到了，已经将属性值加载到内存当中了</span><br><span class="line">    UmountSecondStageRes();</span><br><span class="line"></span><br><span class="line">    // Umount the debug ramdisk after property service has read the .prop files when it means to.</span><br><span class="line">    // 若是debug版本，已经获取了属性值过后，也将卸载/debug_ramdisk</span><br><span class="line">    if (load_debug_prop) &#123;</span><br><span class="line">        UmountDebugRamdisk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 挂载第二阶段（该阶段）的文件系统,第一阶段已经挂载了很多基本的文件系统了以及重要的分区</span><br><span class="line">    // 挂载/apex：简单点说apex为了解决性能而产生的机制，APK可以通过内置升级，但系统升级可是个大问题</span><br><span class="line">    // setup 3</span><br><span class="line">    MountExtraFilesystems();</span><br><span class="line">	...</span><br><span class="line">    // 之前初始化了属性服务，这里将开始属性服务，其实它就是一个socket</span><br><span class="line">    // 创建socket,处理客户端发来的请求，决定是更新属性值还是新增属性值</span><br><span class="line">    // setup 4</span><br><span class="line">    StartPropertyService(&amp;property_fd);</span><br><span class="line">    ...</span><br><span class="line">    // 根据ro.vndk.version 版本号，将/system/vendor_overlay和/product/vendor_overlay挂载在vendor上</span><br><span class="line">    // 也就是会覆盖vendor分区内容</span><br><span class="line">    // setup 5</span><br><span class="line">    fs_mgr_vendor_overlay_mount_all();</span><br><span class="line">    // 根据ro.oem_unlock_supported属性值来决定是否可以对设备进行unlock（解锁）</span><br><span class="line">    // 若ro.oem_unlock_supported：「1」则代表 设备支持刷写unlock,若不支持该值为0</span><br><span class="line">    // 如果设备支持刷写解锁，ro.boot.verifiedbootstate则会为orange，根据orange状态，把androidboot.flash.locked设置为1</span><br><span class="line">    // 如果设备不支持刷新解锁，ro.boot.verifiedbootstate则会为green，根据orange状态，把androidboot.flash.locked设置为0</span><br><span class="line">    // androidboot.flash.locked在系统启动完成后会形成属性值</span><br><span class="line">    // （或 /firmware/android/flash.locked DT 属性）设置为“1”（如果已锁定）或“0”（如果已解锁）来指示锁定状态。</span><br><span class="line">    export_oem_lock_status();</span><br><span class="line">    // 持续监控/proc/mounts 节点(fopen(&quot;/proc/mounts&quot;, &quot;re&quot;)),主要是解析该文件</span><br><span class="line">    // 解析文件中每一行数据，获取挂载点，挂载分区，文件类型，权限等(空格分割/dev/block/dm-33 /mnt/pass_through/0/emulated ext4 rw)</span><br><span class="line">    // 将解析内容生成实体类追加到要挂载的mounts_中，主要就是对mounts文件解析，更新mounts_中的信息</span><br><span class="line">    // setup 6</span><br><span class="line">    MountHandler mount_handler(&amp;epoll);</span><br><span class="line">    ...</span><br><span class="line">    // 将根目录下所有的目录设置为全局共享</span><br><span class="line">    // 将根目录/&#123;分区&#125;类型设置为共享，以便默认情况下所有进程都可以看到任何装载事件（例如/data）</span><br><span class="line">    if (!SetupMountNamespaces()) &#123;</span><br><span class="line">        PLOG(FATAL) &lt;&lt; &quot;SetupMountNamespaces failed&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	// setup 7</span><br><span class="line">    // 创建ActionManager对象和ServiceList对象</span><br><span class="line">    ActionManager&amp; am = ActionManager::GetInstance();</span><br><span class="line">    ServiceList&amp; sm = ServiceList::GetInstance();</span><br><span class="line">    // 加载rc文件，保存到action manager和service list中</span><br><span class="line">    // rc文件中：action 使用 ActionParser，而 service 使用 ServiceParser 解析</span><br><span class="line">    // 主要解析rc中的：service，on,Import,包含了zygote.rc,路径：/system/bin/app_process64</span><br><span class="line">    // 在文件系统挂载的第一阶段，system/vendor分区已经成功挂载，而其它分区的挂载则通过rc来挂载</span><br><span class="line">    // 后面主要分析一下on early-init和on init和zygote</span><br><span class="line">    LoadBootScripts(am, sm);</span><br><span class="line">	...</span><br><span class="line">	// setup 8</span><br><span class="line">    // 构建action和触发器(on early-init)，放到event_queue，等待执行函数</span><br><span class="line">    am.QueueBuiltinAction(SetupCgroupsAction, &quot;SetupCgroups&quot;);</span><br><span class="line">    am.QueueBuiltinAction(SetKptrRestrictAction, &quot;SetKptrRestrict&quot;);</span><br><span class="line">    am.QueueBuiltinAction(TestPerfEventSelinuxAction, &quot;TestPerfEventSelinux&quot;);</span><br><span class="line">    am.QueueEventTrigger(&quot;early-init&quot;);</span><br><span class="line"></span><br><span class="line">    // Queue an action that waits for coldboot done so we know ueventd has set up all of /dev...</span><br><span class="line">    am.QueueBuiltinAction(wait_for_coldboot_done_action, &quot;wait_for_coldboot_done&quot;);</span><br><span class="line">    // ... so that we can start queuing up actions that require stuff from /dev.</span><br><span class="line">    am.QueueBuiltinAction(SetMmapRndBitsAction, &quot;SetMmapRndBits&quot;);</span><br><span class="line">    Keychords keychords;</span><br><span class="line">    am.QueueBuiltinAction(</span><br><span class="line">            [&amp;epoll, &amp;keychords](const BuiltinArguments&amp; args) -&gt; Result&lt;void&gt; &#123;</span><br><span class="line">                for (const auto&amp; svc : ServiceList::GetInstance()) &#123;</span><br><span class="line">                    keychords.Register(svc-&gt;keycodes());</span><br><span class="line">                &#125;</span><br><span class="line">                keychords.Start(&amp;epoll, HandleKeychord);</span><br><span class="line">                return &#123;&#125;;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;KeychordInit&quot;);</span><br><span class="line"></span><br><span class="line">    // Trigger all the boot actions to get us started.</span><br><span class="line">    // 构建action和触发器(on init)，放到event_queue，等待执行函数</span><br><span class="line">    am.QueueEventTrigger(&quot;init&quot;);</span><br><span class="line"></span><br><span class="line">    // Don&#x27;t mount filesystems or start core system services in charger mode.</span><br><span class="line">    // 如果是充电模式则不需要挂载文件系统和不要启动核心服务</span><br><span class="line">    std::string bootmode = GetProperty(&quot;ro.bootmode&quot;, &quot;&quot;);</span><br><span class="line">    if (bootmode == &quot;charger&quot;) &#123;</span><br><span class="line">        am.QueueEventTrigger(&quot;charger&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        am.QueueEventTrigger(&quot;late-init&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Run all property triggers based on current state of the properties.</span><br><span class="line">    // 运行所有属性触发器(action)，例如 on property</span><br><span class="line">    am.QueueBuiltinAction(queue_property_triggers_action, &quot;queue_property_triggers&quot;);</span><br><span class="line"></span><br><span class="line">    // Restore prio before main loop</span><br><span class="line">    // 设置进程优先级，主进程不能被销毁和退出，循环处理rc中的服务相关</span><br><span class="line">    setpriority(PRIO_PROCESS, 0, 0);</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        // By default, sleep until something happens.</span><br><span class="line">        auto epoll_timeout = std::optional&lt;std::chrono::milliseconds&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        auto shutdown_command = shutdown_state.CheckShutdown();</span><br><span class="line">        if (shutdown_command) &#123;</span><br><span class="line">            LOG(INFO) &lt;&lt; &quot;Got shutdown_command &#x27;&quot; &lt;&lt; *shutdown_command</span><br><span class="line">                      &lt;&lt; &quot;&#x27; Calling HandlePowerctlMessage()&quot;;</span><br><span class="line">            HandlePowerctlMessage(*shutdown_command);</span><br><span class="line">            shutdown_state.set_do_shutdown(false);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!(prop_waiter_state.MightBeWaiting() || Service::is_exec_service_running())) &#123;</span><br><span class="line">            // 执行队列中的action</span><br><span class="line">            // 队列中依次执行每个action中携带command对应的执行函数</span><br><span class="line">            am.ExecuteOneCommand();</span><br><span class="line">        &#125;</span><br><span class="line">        if (!IsShuttingDown()) &#123;</span><br><span class="line">            // 处理sm（ServiceList）中服务超时重启相关（init.rc中的service）</span><br><span class="line">            auto next_process_action_time = HandleProcessActions();</span><br><span class="line">            if (next_process_action_time) &#123;</span><br><span class="line">                epoll_timeout = std::chrono::ceil&lt;std::chrono::milliseconds&gt;(</span><br><span class="line">                        *next_process_action_time - boot_clock::now());</span><br><span class="line">                if (*epoll_timeout &lt; 0ms) epoll_timeout = 0ms;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>set1:初始化kernel log，所有的kernel log输出至&#x2F;dev&#x2F;kmsg上,在&#x2F;dev目录下创建一个空文件“.booting”表示初始化正在进行，并设置一些环境变量</p>
<p>set2:初始化属性服务，读取property_contexts文件内容以及读取build.prop内容通过MMAP映射到全局内存中，也就是对所有进程共享该资源。</p>
<p>set3:开始属性服务并创建socket_service,等待新链接去更新或新增属性值。</p>
<p>set4:挂载&#x2F;apex,vendor_overlay等其他分区</p>
<p>set5:根据ro.oem_unlock_supported属性值来决定是否可以对设备进行unlock（解锁）；持续监控&#x2F;proc&#x2F;mounts设备文件，解析文件中每一行数据，获取挂载点，挂载分区，文件类型，权限等。将解析内容生成实体类追加到要挂载的mounts_中并进行挂载</p>
<p>set6:将根目录下所有的目录设置为全局共享</p>
<p>set7:创建ActionManager对象和ServiceList对象，加载并解析rc文件</p>
<p>set8:构建action和触发器(on early-init)，放到event_queue，等待执行函数；构建action和触发器(on init)，放到event_queue，等待执行函数；设置init进程无限循环。其中，zygote进程就是解析rc文件中创建的，然后根据zygote（本质上就是一个socket），通过JNI调用到上层代码，再fork出systemServer.java。还有处理ServiceList中服务超时相关的逻辑。</p>
<h4 id="2-6-Zygote服务"><a href="#2-6-Zygote服务" class="headerlink" title="2.6 Zygote服务"></a>2.6 Zygote服务</h4><p>在init.rc文件中会执行<code>class_start main</code>来启动zygote。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 启动zygote</span><br><span class="line">on nonencrypted</span><br><span class="line">    class_start main</span><br><span class="line">    class_start late_start</span><br></pre></td></tr></table></figure>

<p>这个main就是zygote,可以通过init.{zygote64}.rc来查看，代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server</span><br><span class="line">    # class : 给服务指定一个类属</span><br><span class="line">    class main</span><br><span class="line">    priority -20</span><br><span class="line">    # user 在执行此服务之前先切换用户名。当前默认为root.</span><br><span class="line">    user root</span><br><span class="line">    # 切换组名</span><br><span class="line">    group root readproc reserved_disk</span><br><span class="line">    # 在/dev/socket/下创建一个socket，并传递创建的文件描述符fd给服务进程</span><br><span class="line">    # 其中type必须为dgram或stream,seqpacket.用户名和组名默认为0</span><br><span class="line">    socket zygote stream 660 root system</span><br><span class="line">    socket usap_pool_primary stream 660 root system</span><br><span class="line">    onrestart exec_background - system system -- /system/bin/vdc volume abort_fuse</span><br><span class="line">    onrestart write /sys/power/state on</span><br><span class="line">    onrestart restart audioserver</span><br><span class="line">    onrestart restart cameraserver</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart netd</span><br><span class="line">    onrestart restart wificond</span><br><span class="line">    writepid /dev/cpuset/foreground/tasks</span><br><span class="line">    # oneshot : 当此服务退出时不会自动重启.</span><br><span class="line">    # disabled:服务不会自动运行，必须显式地通过服务器来启动</span><br><span class="line">    # 据设备相关的关键服务，如果在4分钟内，此服务重复启动了4次，那么设备将会重启进入还原模式。</span><br><span class="line">    critical window=$&#123;zygote.critical_window.minute:-off&#125; target=zygote-fatal</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第二个参数就是服务进程的名称，通过class指定函数入口，并且位于：<code>/system/bin/app_process64</code>,可以看到<code>audioserver</code>，<code>cameraserver</code>，<code>media</code>，<code>netd</code>，<code>wificond</code>这些进程都隶属于zygote进程。</p>
<p><strong>zygote进程的初始化</strong></p>
<p>zygote main的位置为$AOSP&#x2F;framework&#x2F;base&#x2F;app_process&#x2F;app_main.cpp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char* const argv[])</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv));</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // 如果zygote为true则代表即将创建该进程</span><br><span class="line">    // 如果startSystemServer为true则代表创建zygote时也会创建SystemServer</span><br><span class="line">    // 系统正常启动都会将这两个bool默认给到true</span><br><span class="line">    // 因为rc启动main后携带了--zygote和--start-system-server两个参数</span><br><span class="line">    bool zygote = false;</span><br><span class="line">    bool startSystemServer = false;</span><br><span class="line">    bool application = false;</span><br><span class="line">    String8 niceName;</span><br><span class="line">    String8 className;</span><br><span class="line"></span><br><span class="line">    ++i;  // Skip unused &quot;parent dir&quot; argument.</span><br><span class="line">    while (i &lt; argc) &#123;</span><br><span class="line">        const char* arg = argv[i++];</span><br><span class="line">        if (strcmp(arg, &quot;--zygote&quot;) == 0) &#123;// zygote将为true,名称就叫：zygote</span><br><span class="line">            zygote = true;</span><br><span class="line">            niceName = ZYGOTE_NICE_NAME;</span><br><span class="line">        &#125; else if (strcmp(arg, &quot;--start-system-server&quot;) == 0) &#123;// startSystemServer将为true</span><br><span class="line">            startSystemServer = true;</span><br><span class="line">        &#125; else if (strcmp(arg, &quot;--application&quot;) == 0) &#123;</span><br><span class="line">            application = true;</span><br><span class="line">        &#125; else if (strncmp(arg, &quot;--nice-name=&quot;, 12) == 0) &#123;</span><br><span class="line">            niceName.setTo(arg + 12);</span><br><span class="line">        &#125; else if (strncmp(arg, &quot;--&quot;, 2) != 0) &#123;</span><br><span class="line">            className.setTo(arg);</span><br><span class="line">            break;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            --i;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Vector&lt;String8&gt; args;</span><br><span class="line">    if (!className.isEmpty()) &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 进入创建zygote模式</span><br><span class="line">        // 创建/data/dalvik-cache，为后续会创建Dalvik虚拟机做准备</span><br><span class="line">        maybeCreateDalvikCache();</span><br><span class="line"></span><br><span class="line">        // 如果startSystemServer为true的话(默认为true)</span><br><span class="line">        // 将”start-system-server”放入启动的参数args</span><br><span class="line">        if (startSystemServer) &#123;</span><br><span class="line">            args.add(String8(&quot;start-system-server&quot;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        char prop[PROP_VALUE_MAX];</span><br><span class="line">        ...</span><br><span class="line">        // 将所有剩余参数传递给args，例如application或tool或start-system-server或abi</span><br><span class="line">        // 这些启动参数将会传递到其他进程中，后续取出参数决定是否启动systemServer等操作</span><br><span class="line">        for (; i &lt; argc; ++i) &#123;</span><br><span class="line">            args.add(String8(argv[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // zygote为真，将创建zygote，该args启动参数会包含start-system-server</span><br><span class="line">    // 调用runtime(AppRuntime)的start来启动zygote，将args传入，因为args包含了启动SystemServer的标志</span><br><span class="line">    if (zygote) &#123;</span><br><span class="line">        runtime.start(&quot;com.android.internal.os.ZygoteInit&quot;, args, zygote);</span><br><span class="line">    &#125; else if (className) &#123;</span><br><span class="line">        runtime.start(&quot;com.android.internal.os.RuntimeInit&quot;, args, zygote);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        fprintf(stderr, &quot;Error: no class name or --zygote supplied.\n&quot;);</span><br><span class="line">        app_usage();</span><br><span class="line">        LOG_ALWAYS_FATAL(&quot;app_process: no class name or --zygote supplied.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码就是启动zygote和将start-system-server放入启动参数，后续会读取参数启动SystemServer,继续分析一下runtime.start的com.android.internal.os.ZygoteInit”进程，位于：$AOSP&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;AndroidRuntime.cpp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">void AndroidRuntime::start(const char* className, const Vector&lt;String8&gt;&amp; options, bool zygote)</span><br><span class="line">&#123;</span><br><span class="line">    ALOGD(&quot;&gt;&gt;&gt;&gt;&gt;&gt; START %s uid %d &lt;&lt;&lt;&lt;&lt;&lt;\n&quot;,</span><br><span class="line">            className != NULL ? className : &quot;(unknown)&quot;, getuid());</span><br><span class="line">    // 默认会启动SystemServer</span><br><span class="line">    static const String8 startSystemServer(&quot;start-system-server&quot;);</span><br><span class="line">    // 是否私有，如果SystemServer会被创建时，将会设置为私有</span><br><span class="line">    bool primary_zygote = false;</span><br><span class="line"></span><br><span class="line">    for (size_t i = 0; i &lt; options.size(); ++i) &#123;</span><br><span class="line">        // options就是传递过来的args,默认是包含了start-system-server</span><br><span class="line">        if (options[i] == startSystemServer) &#123;</span><br><span class="line">            primary_zygote = true;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取环境变量，这里第一次执行时默认为空，所以rootDir不存在</span><br><span class="line">    // = 将直接拿到/system作为rootDir并设置环境变量</span><br><span class="line">    const char* rootDir = getenv(&quot;ANDROID_ROOT&quot;);</span><br><span class="line">    if (rootDir == NULL) &#123;</span><br><span class="line">        rootDir = &quot;/system&quot;;</span><br><span class="line">        if (!hasDir(&quot;/system&quot;)) &#123;</span><br><span class="line">            LOG_FATAL(&quot;No root directory specified, and /system does not exist.&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        setenv(&quot;ANDROID_ROOT&quot;, rootDir, 1);</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">    /* start the virtual machine */</span><br><span class="line">    // 这里就开始启动虚拟机了</span><br><span class="line">    // JNI功能初始化</span><br><span class="line">    JniInvocation jni_invocation;</span><br><span class="line">    jni_invocation.Init(NULL);</span><br><span class="line">    JNIEnv* env;</span><br><span class="line">    // 创建Dalvik虚拟机(这里--&gt;DVM==JavaVM)</span><br><span class="line">    if (startVm(&amp;mJavaVM, &amp;env, zygote, primary_zygote) != 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    onVmCreated(env);</span><br><span class="line"></span><br><span class="line">    // 调用startReg函数用来为DVM注册JNI</span><br><span class="line">    if (startReg(env) &lt; 0) &#123;</span><br><span class="line">        ALOGE(&quot;Unable to register all android natives\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jclass stringClass;</span><br><span class="line">    jobjectArray strArray;</span><br><span class="line">    jstring classNameStr;</span><br><span class="line">	// 通过反射拿到String类型</span><br><span class="line">    stringClass = env-&gt;FindClass(&quot;java/lang/String&quot;);</span><br><span class="line">    assert(stringClass != NULL);</span><br><span class="line">    //options就是app_main.cpp传递过来的args,包含了start-system-server</span><br><span class="line">    // 将options转换为array list对象</span><br><span class="line">    strArray = env-&gt;NewObjectArray(options.size() + 1, stringClass, NULL);</span><br><span class="line">    assert(strArray != NULL);</span><br><span class="line">    //从app_main的main函数得知className为com.android.internal.os.ZygoteInit</span><br><span class="line">    classNameStr = env-&gt;NewStringUTF(className);</span><br><span class="line">    assert(classNameStr != NULL);</span><br><span class="line">    // 将数据转换给java类型的array 数组</span><br><span class="line">    env-&gt;SetObjectArrayElement(strArray, 0, classNameStr);</span><br><span class="line"></span><br><span class="line">    for (size_t i = 0; i &lt; options.size(); ++i) &#123;</span><br><span class="line">        jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).string());</span><br><span class="line">        assert(optionsStr != NULL);</span><br><span class="line">        env-&gt;SetObjectArrayElement(strArray, i + 1, optionsStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Start VM.  This thread becomes the main thread of the VM, and will</span><br><span class="line">     * not return until the VM exits.</span><br><span class="line">     */</span><br><span class="line">     // 启动com.android.internal.os.ZygoteInit，该线程成为VM的主进程，在VM退出之前不会返回</span><br><span class="line">    char* slashClassName = toSlashClassName(className != NULL ? className : &quot;&quot;);</span><br><span class="line">    jclass startClass = env-&gt;FindClass(slashClassName);</span><br><span class="line">    if (startClass == NULL) &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 通过反射的方式，找到ZygoteInit的main函数</span><br><span class="line">        // 若获取到内容则执行else</span><br><span class="line">        jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, &quot;main&quot;,</span><br><span class="line">            &quot;([Ljava/lang/String;)V&quot;);</span><br><span class="line">        if (startMeth == NULL) &#123;</span><br><span class="line">            ALOGE(&quot;JavaVM unable to find main() in &#x27;%s&#x27;\n&quot;, className);</span><br><span class="line">            /* keep going */</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 通过JNI调用ZygoteInit的main函数,将args(strArray)传递到java层</span><br><span class="line">            // 因为ZygoteInit的main函数是Java编写的，因此需要通过JNI调用</span><br><span class="line">            // 所以这里继续跟到java层面:ZygoteInit.java</span><br><span class="line">            env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</span><br><span class="line">			...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 若执行到这里，则会结束zygote创建，关闭jvm</span><br><span class="line">    free(slashClassName);</span><br><span class="line">    ALOGD(&quot;Shutting down VM\n&quot;);</span><br><span class="line">    if (mJavaVM-&gt;DetachCurrentThread() != JNI_OK)</span><br><span class="line">        ALOGW(&quot;Warning: unable to detach main thread\n&quot;);</span><br><span class="line">    if (mJavaVM-&gt;DestroyJavaVM() != 0)</span><br><span class="line">        ALOGW(&quot;Warning: VM did not shut down cleanly\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上的代码主要就是初始化了JNI（c++与Java交互）功能并创建并启动了VM虚拟机，通过反射的方式去启动ZygoteInit.java的main方法，并将args参数（包含了是否启动SystemServer的参数）传递过去。</p>
<p>后续zygoteinit以及loop设置，fork出子应用程序进程等不再关注。</p>
<p>参考资料：</p>
<p>《深入解析Android 5.0系统 (刘超) 》</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/q1210249579/article/details/128652348">https://blog.csdn.net/q1210249579/article/details/128652348</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/q1210249579/article/details/128637218">https://blog.csdn.net/q1210249579/article/details/128637218</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/q1210249579/article/details/128759108">https://blog.csdn.net/q1210249579/article/details/128759108</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/q1210249579/article/details/128782204">https://blog.csdn.net/q1210249579/article/details/128782204</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://github.com/2025/08/21/android%E5%88%86%E5%8C%BA%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dz">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog of dz">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | blog of dz">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/21/android%E5%88%86%E5%8C%BA%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">Android分区结构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-21 19:04:06" itemprop="dateCreated datePublished" datetime="2025-08-21T19:04:06+08:00">2025-08-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Android-分区结构"><a href="#Android-分区结构" class="headerlink" title="Android 分区结构"></a>Android 分区结构</h1><p>Android 分区结构大致可以分为：non-A&#x2F;B分区（又可称为传统分区结构）、A&#x2F;B分区结构以及动态分区</p>
<p>Android O之后引入A&#x2F;B分区结构 。A&#x2F;B分区结构，顾名思义，将系统分区分成了A和B两个槽(slot)，手机启动时会选择A槽或者B槽启动，运行过程中仅使用当前槽位的分区。一旦当前运行的槽出现问题，系统仍可以选择另一个槽进行启动，从而保证系统良好的可用性。</p>
<p>Android Q(10.0)之后，系统支持动态分区。它将多个系统只读分区（包括system、product、vendor、odm或者其他厂商自定义分区）合并为一个super分区。物理分区只有super分区的概念，而没有system等分区。</p>
<p> <img src="/images/android%E5%88%86%E5%8C%BA%E6%BC%94%E5%8F%98%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="android分区演变示意图"> </p>
<table>
<thead>
<tr>
<th>non-A&#x2F;B</th>
</tr>
</thead>
<tbody><tr>
<td>bootloader：设备启动后，会先进入bootloader程序，这里会通过判断开机时的按键组合（也会有一些其他判断条件，暂不赘述）选择启动到哪种模式，这里主要有Android系统、recovery模式、fastboot模式等。</td>
</tr>
<tr>
<td>boot：包含有Android系统的kernel和ramdisk。如果bootloader选择启动Android系统，则会引导启动此分区的kernel并加载ramdisk，完成内核启动。</td>
</tr>
<tr>
<td>system：包含有Android系统的可执行程序、库、系统服务和app等。内核启动后，会运行第一个用户态进程init，其会依据init.rc文件中的规则启动Android系统组件，这些系统组件就在system分区中。将Android系统组件启动完成后，最后会启动系统app —— launcher桌面，至此完成Android系统启动。</td>
</tr>
<tr>
<td>vendor：包含有厂商私有的可执行程序、库、系统服务和app等。可以将此分区看做是system分区的补充，厂商定制ROM的一些功能都可以放在此分区。</td>
</tr>
<tr>
<td>userdata：用户存储空间。一般新买来的手机此分区几乎是空的，用户安装的app以及用户数据都是存放在此分区中。用户通过系统文件管理器访问到的手机存储（sdcard）即此分区的一部分，是通过fuse或sdcardfs这类用户态文件系统实现的一块特殊存储空间。</td>
</tr>
<tr>
<td>recovery：包含recovery系统的kernel和ramdisk。如果bootloader选择启动recovery模式，则会引导启动此分区的kernel并加载ramdisk，并启动其中的init继而启动recovery程序，至此可以操作recovery模式功能（主要包括OTA升级、双清等）。</td>
</tr>
<tr>
<td>cache：主要用于缓存系统升级OTA包等。双清就是指对userdata分区和cache分区的清理。</td>
</tr>
<tr>
<td>misc：主要用于Android系统和bootloader通信，使Android系统能够重启进入recovery系统并执行相应操作。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>A&#x2F;B</th>
</tr>
</thead>
<tbody><tr>
<td>bootloader：功能同non-A&#x2F;B的bootloader，只是此处会根据A&#x2F;B槽的bootable、successful、active等标识来选择启动哪个槽。根据不同厂商的实现，可以是唯一的不区分A&#x2F;B的bootloader，也可以自定义，例如高通的实现bootloader是由唯一的pbl（此分区无法擦写）来选择A&#x2F;B槽，启动xbl_a&#x2F;xbl_b，再启动abl_a&#x2F;abl_b。</td>
</tr>
<tr>
<td>boot_a&#x2F;boot_b：包含kernel和recovery的ramdisk。recovery打包在boot分区中，则不再需要recovery分区。并且recovery系统也不再负责OTA升级（由Android系统中update_engine服务负责），仅负责双清等其他操作。</td>
</tr>
<tr>
<td>system_a&#x2F;system_b：功能同non-A&#x2F;B的system分区，只是区分了A和B两个槽。</td>
</tr>
<tr>
<td>vendor_a&#x2F;vendor_b：功能同non-A&#x2F;B的vendor分区，只是区分了A和B两个槽。</td>
</tr>
<tr>
<td>userdata：功能同non-A&#x2F;B的userdata，并且用户数据仅存储一份，不区分A&#x2F;B。</td>
</tr>
<tr>
<td>misc：功能同non-A&#x2F;B的misc，不区分A&#x2F;B。</td>
</tr>
<tr>
<td>persist：用来存储一些持久化数据，不会随着双清、OTA等操作被清除。不区分A&#x2F;B。</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://github.com/2025/08/21/android%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%A0%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dz">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog of dz">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | blog of dz">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/21/android%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%A0%94/" class="post-title-link" itemprop="url">android系统调研</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-21 19:04:06" itemprop="dateCreated datePublished" datetime="2025-08-21T19:04:06+08:00">2025-08-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="ANDROID系统调研"><a href="#ANDROID系统调研" class="headerlink" title="ANDROID系统调研"></a>ANDROID系统调研</h1><h4 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h4><p>由于AOSP以及官方文档较多，除第一部分AOSP框架以外，现选取ART、Bionic以及JNI作为主要的调研对象。性能分析工具后续计划补充。</p>
<h2 id="1-AOSP架构"><a href="#1-AOSP架构" class="headerlink" title="1.AOSP架构"></a>1.AOSP架构</h2><p><img src="https://source.android.google.cn/static/images/android_stack.png?hl=zh-cn" alt="AOSP 软件堆栈架构。"></p>
<p>其中，自上而下分别是：</p>
<p>*Android Apps:*完全使用 Android API 开发的应用</p>
<p>Priviledged Apps:使用 Android 和系统 API 组合创建的应用，需要作为特权应用预安装在设备上</p>
<p>Device Manufacture Apps:结合使用 Android API、系统 API 并直接访问 Android 框架实现而创建的应用</p>
<p>System API:系统 API 表示仅供合作伙伴和 OEM 纳入捆绑应用的 Android API</p>
<p>Android API:Android API 是面向第三方 Android 应用开发者的公开 API</p>
<p>Android Framework:构建应用所依据的一组 Java 类、接口和其他预编译代码。框架的某些部分可通过使用 Android API 公开访问。框架的其他部分只能由 OEM 通过系统 API 来访问。Android 框架代码在应用进程内运行。</p>
<p>System Service:系统服务是重点突出的模块化组件，例如 <code>system_server</code>、SurfaceFlinger 和 MediaService。Android 框架 API 提供的功能可以与系统服务进行通信，以访问底层硬件。</p>
<p>ART:AOSP 提供的 Java 运行时环境。 ART 会将应用的字节码转换为由设备运行时环境执行的处理器专有指令。</p>
<p>Hardware abstration layer(HAL):HAL 是一个抽象层，其中包含硬件供应商要实现的标准接口</p>
<p>Native daemons and libraries:该层中的原生守护程序包括 <code>init</code>、<code>healthd</code>、<code>logd</code> 和 <code>storaged</code>。这些守护程序直接与内核或其他接口进行交互，并且不依赖于基于用户空间的 HAL 实现。该层中的原生库包括 <code>libc</code>、<code>liblog</code>、<code>libutils</code>、<code>libbinder</code> 和 <code>libselinux</code>。这些原生库直接与内核或其他接口进行交互，并且不依赖于基于用户空间的 HAL 实现。</p>
<p>Kernel:内核是任何操作系统的中心部分，并与设备上的底层硬件进行通信</p>
<h2 id="2-ART"><a href="#2-ART" class="headerlink" title="2.ART"></a>2.ART</h2><p><strong>A</strong>ndroid <strong>R</strong>un<strong>t</strong>ime（ART）是安卓上一些应用和系统服务的运行环境。</p>
<h3 id="2-1-JVM、DVM分析比较"><a href="#2-1-JVM、DVM分析比较" class="headerlink" title="2.1 JVM、DVM分析比较"></a>2.1 JVM、DVM分析比较</h3><p>ART的前身是Dalvik，传统的Dalvik其实就是一个java虚拟机。而google没有采用JVM不仅仅是因为版权的问题，DVM和JVM在技术细节上有许多不同之处。</p>
<table>
<thead>
<tr>
<th align="center">不同点</th>
<th align="center">DVM</th>
<th align="center">JVM</th>
</tr>
</thead>
<tbody><tr>
<td align="center">执行的字节码不同</td>
<td align="center">DVM执行的是.dex格式文件</td>
<td align="center">JVM执行的是.class文件</td>
</tr>
<tr>
<td align="center">基于的架构不同</td>
<td align="center">基于寄存器</td>
<td align="center">基于虚拟栈</td>
</tr>
<tr>
<td align="center">GC实现</td>
<td align="center">单独申请一块空间，以位图的形式保存堆上的对象的标记</td>
<td align="center">对象开头的地方留一小块空间</td>
</tr>
</tbody></table>
<p><strong>执行的字节码不同</strong></p>
<p>在Java SE程序中，Java类会被编译成一个或多个.class文件，打包成jar文件，然后JVM会通过相应的.class文件和jar文件获取相应的字节码。</p>
<p>执行顺序为： .java -&gt; .class -&gt; .jar</p>
<p>而DVM会用dx工具将所有的.class文件转换为一个.dex文件，然后DVM会从.dex文件读取指令和数据。</p>
<p>执行顺序为： .java -&gt; .class -&gt; .dex</p>
<p><img src="https://s2.ax1x.com/2019/05/31/VQviBn.png" alt="VQviBn.png"></p>
<p>如图所示，.jar文件包含多个.class文件，每个.class文件包含了类的常量池、方法、属性等，因此JVM在加载jar文件的时候，会加载所有的.class文件，这种加载方式很慢，不适用于移动设备。</p>
<p>而.dex文件将所有.class文件的信息整合在一起，并且通过去除.class文件中的冗余信息，减少了I&#x2F;O操作，提升了类的查找速度。</p>
<p><strong>基于的架构不同</strong></p>
<p>JVM基于栈则意味着需要去栈中读写数据，所需的指令会更多，这样会导致速度慢，对于性能有限的移动设备，显然不是很适合。</p>
<p>DVM是基于寄存器的，它没有基于栈的虚拟机在拷贝数据而使用的大量的出入栈指令，同时指令更紧凑更简洁。但是由于显示指定了操作数，所以基于寄存器的指令会比基于栈的指令要大，但是由于指令数量的减少，总的代码数不会增加多少。</p>
<h3 id="2-2-ART执行方式"><a href="#2-2-ART执行方式" class="headerlink" title="2.2  ART执行方式"></a>2.2  ART执行方式</h3><p><img src="https://source.android.google.cn/docs/core/runtime/images/jit-arch.png?hl=zh-cn" alt="JIT 架构"></p>
<p>Android Runtime (ART) 包含一个具备代码分析功能的即时 (JIT) 编译器，该编译器可以在 Android  应用运行时持续提高其性能。JIT 编译器对 Android 运行组件当前的预先 (AOT)  编译器进行了补充，可以提升运行时性能，节省存储空间，加快应用和系统更新速度。相较于 AOT 编译器，JIT  编译器的优势也更为明显，因为在应用自动更新期间或在无线下载 (OTA) 更新期间重新编译应用时，它不会拖慢系统速度。</p>
<p>尽管 JIT 和 AOT 使用相同的编译器，它们所进行的一系列优化也较为相似，但它们生成的代码可能会有所不同。JIT 会利用运行时类型信息，可以更高效地进行内联，并可让堆栈替换 (OSR) 编译成为可能，而这一切都会使其生成的代码略有不同。</p>
<p>Android早期是aot的方式先编译成机器码，然后再运行的，这样会导致安装时间变长，后面的版本改成jit编译方式，在运行时编译，这样会导致运行速度较慢。android7.0之后的版本支持jit+oat的方式编译，支持app配置baseline-profile的方式设置热点代码。</p>
<p>1.最初安装应用时不进行任何 AOT 编译。应用前几次运行时，系统会对其进行解译，并对经常执行的方法进行 JIT 编译。</p>
<p>2.当设备闲置和充电时，编译守护程序会运行，以便根据在应用前几次运行期间生成的配置文件对常用代码进行 AOT 编译。</p>
<p>3.下一次重新启动应用时将会使用配置文件引导型代码，并避免在运行时对已经过编译的方法进行 JIT 编译。在应用后续运行期间经过 JIT 编译的方法将会添加到配置文件中，然后编译守护程序将会对这些方法进行 AOT 编译。</p>
<p>附：部分性能分析工具oprofile</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://github.com/2025/08/21/git%E4%BD%BF%E7%94%A8%E5%87%A0%E5%88%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dz">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog of dz">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | blog of dz">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/21/git%E4%BD%BF%E7%94%A8%E5%87%A0%E5%88%99/" class="post-title-link" itemprop="url">git使用几则</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-21 19:04:06" itemprop="dateCreated datePublished" datetime="2025-08-21T19:04:06+08:00">2025-08-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-直接使用git-clone下载子模块项目"><a href="#1-直接使用git-clone下载子模块项目" class="headerlink" title="1.直接使用git clone下载子模块项目"></a>1.直接使用git clone下载子模块项目</h2><p>git clone –recursive [url]</p>
<h2 id="2-先下载部分内容，再对子模块进行初始化"><a href="#2-先下载部分内容，再对子模块进行初始化" class="headerlink" title="2.先下载部分内容，再对子模块进行初始化"></a>2.先下载部分内容，再对子模块进行初始化</h2><p>初始化本地子模块配置文件<br>git submodule init</p>
<p>更新项目，抓取子模块内容<br>git submodule update</p>
<h2 id="3-git-pull合并时与本地代码发生冲突的修改的正确姿势"><a href="#3-git-pull合并时与本地代码发生冲突的修改的正确姿势" class="headerlink" title="3.git pull合并时与本地代码发生冲突的修改的正确姿势"></a>3.git pull合并时与本地代码发生冲突的修改的正确姿势</h2><p>首先，git commit提交本地尚未保存的修改以保留自己的工作量<br>其次，使用git branch创建一个新的分支<br>然后使用git reset &amp;&amp;git clean回退发生冲突之间的版本，并git pull<br>代码同步完成后在主分支上使用git merge合并分支，这时git merge会合并不冲突的文件并提示冲突的文件，大意格式如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">// 当前分支的代码</span><br><span class="line">=======</span><br><span class="line">// 要合并的分支的代码</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; branch-name</span><br></pre></td></tr></table></figure>
<p>此时进行选择留下哪个分支的代码，并删除其余代码进行一次提交，git push到仓库中。<br>在本人的blog仓库中6-11有相关的测试，可以查看log</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://github.com/2025/08/21/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="dz">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blog of dz">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | blog of dz">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/21/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-21 19:04:06" itemprop="dateCreated datePublished" datetime="2025-08-21T19:04:06+08:00">2025-08-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">dz</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
